[合集 - 嵌入式笔记(3)](https://github.com)

[1.01-ARM架构汇编09-24](https://github.com/xiaolujiao/p/19108552):[cmespeed楚门加速器](https://77yingba.com)[2.02-链表09-24](https://github.com/xiaolujiao/p/19109092)

3.03-堆和栈09-24

收起

# 概述

堆和栈是程序运行时**内存分配的两个核心区域**，用途、管理方式和特性差异很大。且堆（内存区域）与上篇文章的链表（数据结构）有一定关联，但本质不同 —— 堆是一块内存空间，而链表常被用作**管理堆内存的工具**。下面进行堆栈详细解释：

# 一、核心概念与特性对比

| 类型 | 本质定义 | 管理方式 | 核心特性 | 典型操作效率 |
| --- | --- | --- | --- | --- |
| **栈（Stack）** | 程序运行时的**临时内存区域** | 编译器自动管理（压栈 / 弹栈） | 连续空间、后进先出（LIFO）、大小固定（预设） | 极快（O (1)，栈指针直接操作） |
| **堆（Heap）** | 程序运行时的**动态内存区域** | 开发者手动管理（`malloc`/`free`） | 非连续空间、分配 / 释放顺序灵活、大小较大 | 较慢（O (n)，需遍历空闲块） |
| **链表（Linked List）** | 一种**数据结构**（节点通过指针连接） | 手动通过指针操作（插入 / 删除） | 非连续存储、动态增减、节点含数据和指针域 |  |

## 1. 栈的工作原理

栈就像一个 “叠盘子” 的结构：

* 函数调用时，局部变量、参数、返回地址等被 “压栈”（栈指针向下增长）；
* 函数执行结束时，这些数据被 “弹栈”（栈指针向上回退），内存自动释放。

例如：

```
void func() {
    int a = 10;  // a存储在栈上，函数结束后自动释放
    char b[5] = "abc";  // 数组b也在栈上
}
```

## 2. 堆的工作原理

堆是一块内存空间，可以从中分配出一个小buffer，用完后再把它放回去：

* 用`malloc`/`calloc`申请内存（从堆中分配）；
* 用`free`释放内存（归还给堆，否则导致内存泄漏）。

例如：

```
void func() {
    int* p = (int*)malloc(sizeof(int));  // 从堆分配4字节
    *p = 100;  // 堆内存中存储数据
    free(p);   // 必须手动释放，否则内存泄漏
}
```

# 二、堆和链表的关系

堆本身是一块 “原始内存区域”，但操作系统或编译器需要一种方式管理它 ——**记录哪些内存是空闲的、哪些已被分配、如何高效分配和回收**。而**链表是管理堆内存的常用工具**。

具体来说，堆的管理常使用 **“空闲链表（Free List）”** 结构：

* 所有未被分配的空闲内存块，通过链表连接起来（每个空闲块包含 “块大小” 和 “下一个空闲块的指针”）；
* 当调用`malloc`时，内存管理器遍历空闲链表，找到一块足够大的空闲块，分割后分配给用户，剩余部分仍留在链表中；
* 当调用`free`时，内存管理器将释放的块重新加入空闲链表，甚至会合并相邻的空闲块（减少碎片）。

#### 示例：简化的堆管理

假设堆内存初始是一整块空闲区域，用链表记录：

```
// 空闲块结构（链表节点）
typedef struct FreeBlock {
    size_t size;  // 空闲块大小
    struct FreeBlock* next;  // 下一个空闲块
} FreeBlock;

// 初始空闲链表（堆的全部空间）
FreeBlock* free_list = (FreeBlock*)HEAP_START;
free_list->size = HEAP_SIZE - sizeof(FreeBlock);  // 减去节点自身大小
free_list->next = NULL;
```

当分配内存时：

```
void* my_malloc(size_t need_size) {
    FreeBlock* cur = free_list;
    FreeBlock* prev = NULL;
    
    // 遍历空闲链表，找足够大的块
    while (cur && cur->size < need_size) {
        prev = cur;
        cur = cur->next;
    }
    
    if (cur) {
        // 分割空闲块（剩余部分仍为空闲）
        void* alloc_ptr = cur + 1;  // 跳过链表节点，返回实际数据地址
        size_t remaining = cur->size - need_size - sizeof(FreeBlock);
        
        if (remaining > 0) {
            // 创建新的空闲块节点
            FreeBlock* new_free = (FreeBlock*)((char*)alloc_ptr + need_size);
            new_free->size = remaining;
            new_free->next = cur->next;
            
            // 更新链表连接
            if (prev) prev->next = new_free;
            else free_list = new_free;
        } else {
            // 空闲块刚好够用，从链表中移除
            if (prev) prev->next = cur->next;
            else free_list = cur->next;
        }
        return alloc_ptr;
    }
    return NULL;  // 内存不足
}
```

可以看到，堆的分配过程本质是对 “空闲链表” 的操作 —— 这就是堆和链表的核心关联：**链表是管理堆内存的 “账本”**，让内存分配和释放可追踪。

# 三、在 RTOS 中的具体应用

RTOS 的核心是 “实时响应” 和 “高效管理任务 / 资源”，堆、栈、链表各司其职，又相互配合。

## 1. 栈：支撑任务独立运行的 “临时内存”

RTOS 中**每个任务都有独立的栈**（任务栈），这是栈最核心的应用，原因是：

* 任务切换时需要保存 / 恢复现场（保存寄存器值、函数返回地址等），这些数据必须存储在任务私有的栈中(也就是为什么创建任务时，会传递栈大小参数，具体见下述实例)；
* 任务执行过程中的局部变量、函数调用参数等临时数据，也存储在自己的栈中。

**实例**：
在 FreeRTOS 中，创建任务时必须指定栈大小（如`xTaskCreate`的`usStackDepth`参数）：

```
// 任务栈大小为1024字
xTaskCreate(task_func, "Task1", 1024, NULL, 1, &task_handle);
```

* 若栈大小不足，任务可能因 “栈溢出” 崩溃（RTOS 通常提供栈溢出检测机制）；
* 栈由编译器自动管理，任务运行时自动分配局部变量，任务切换时 RTOS 内核自动保存栈指针（`sp`寄存器），确保切换后能恢复执行状态。

## 2. 堆：动态分配资源的 “共享内存”

RTOS 中堆用于**动态创建内核对象**（如任务控制块 TCB、消息队列、信号量等），但有严格限制：

* **标准堆的问题**：`malloc`/`free`可能导致内存碎片（多次分配 / 释放后，空闲内存分散成小块，无法满足大内存申请），且执行时间不确定（遍历空闲块耗时不固定），这与 RTOS 的 “实时性” 冲突。
* **RTOS 的优化方案**：多数 RTOS（如 FreeRTOS、uC/OS）提供 “内存池（Memory Pool）” 替代标准堆 —— 预先划分固定大小的内存块，用链表管理（见下文 “链表的作用”），分配 / 释放时间固定（O (1)）。

**实例**：
FreeRTOS 的动态内存管理，本质是对堆的封装，但其内部用链表管理空闲块（避免碎片的合并算法）：

```
// 从堆动态创建消息队列（内部调用堆分配函数）
QueueHandle_t xQueue = xQueueCreate(5, sizeof(int)); // 队列可存5个int
```

## 3. 链表：管理内核对象的 “高效工具”

链表是 RTOS 内核的 “骨架”，用于**组织和快速操作各种对象**（任务、消息、定时器等），因双向循环链表的插入 / 删除效率极高（O (1)），完美适配 RTOS 的实时性需求。

**核心应用场景**：

* **任务管理**：
  所有任务的 TCB（任务控制块）通过双向循环链表组织，按状态（就绪、阻塞、挂起）分成不同链表。例如 “就绪链表” 按优先级排序，调度器只需从链表头部取最高优先级任务运行：

  ```
  // 简化的TCB结构
  typedef struct TCB {
      int priority;       // 任务优先级
      void* stack_ptr;    // 任务栈指针
      struct TCB* prev;   // 前序节点（双向链表）
      struct TCB* next;   // 后序节点（双向链表）
  } TCB;
  ```
* **消息队列**：
  消息通过链表串联，新消息插入尾部，接收时从头部取出，无需预先分配固定大小的数组，避免空间浪费：

  ```
  // 消息节点（链表结构）
  typedef struct MsgNode {
      void* data;         // 消息数据
      struct MsgNode* next; // 下一个消息
  } MsgNode;
  ```
* **内存池管理**：
  内存池中的空闲块用链表连接，分配时取链表头部节点，释放时将节点插回链表，操作时间固定：

  ```
  // 内存池空闲块（链表节点）
  typedef struct PoolBlock {
      struct PoolBlock* next; // 下一个空闲块
  } PoolBlock;
  ```
* **RTOS 的链表设计特点**：
  几乎所有 RTOS 都用**宏定义封装链表操作**（如`vListInsert`、`uxListRemove`），避免重复代码；且链表节点通常嵌入到对象结构体中（如 TCB 包含`prev`/`next`指针），而非单独定义，节省内存。

# 四、RTOS角度三者的关联与区别

| 关系维度 | 具体说明 |
| --- | --- |
| **堆与链表** | 堆的管理依赖链表（如 “空闲链表” 记录未分配内存块），但堆是内存区域，链表是管理工具；RTOS 中内存池用链表管理空闲块，替代标准堆以保证实时性。 |
| **栈与堆** | 栈是任务私有、临时内存（自动管理），堆是全局共享、持久内存（需手动管理）；RTOS 中任务栈大小固定，堆（或内存池）用于动态创建内核对象。 |
| **链表与栈 / 堆** | 链表是数据结构，可存储在栈或堆中：RTOS 的静态链表（编译时分配）存储在栈或全局区，动态链表（运行时创建）存储在堆中。 |
